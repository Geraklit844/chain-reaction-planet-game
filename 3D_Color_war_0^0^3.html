<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Цепная реакция 3D: Планета</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
            touch-action: none; /* Предотвращает прокрутку страницы на мобильных */
        }
        canvas {
            display: block;
            touch-action: none; /* Важно для мобильных устройств */
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 1.2em;
            background: rgba(0,0,0,0.6);
            padding: 10px 15px;
            border-radius: 8px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 150px;
        }
        .player-status-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .player-status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.5);
        }
        #current-player-text {
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255,255,255,0.7);
        }

        #restart-button, #menu-button {
            position: absolute;
            padding: 12px 25px;
            font-size: 1.1em;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: #3498db;
            color: white;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 100;
        }
        #restart-button:hover, #menu-button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }
        #restart-button {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        #menu-button {
            bottom: 20px;
            right: 20px;
        }
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 2.5em;
            font-weight: bold;
            text-align: center;
            z-index: 200;
            display: none; /* Hidden by default */
        }
        #game-over-overlay button {
            margin-top: 30px;
        }
    </style>
</head>
<body>
    <div id="info">
        <div class="player-status-info">Игрок 1: <span id="player-color-0" class="player-status-dot"></span></div>
        <div class="player-status-info">Игрок 2: <span id="player-color-1" class="player-status-dot"></span></div>
        <div class="player-status-info">Игрок 3: <span id="player-color-2" class="player-status-dot"></span></div>
        <div class="player-status-info">Игрок 4: <span id="player-color-3" class="player-status-dot"></span></div>
        <br>
        Текущий ход: <span id="current-player-text">Игрок 1</span>
    </div>
    <button id="restart-button">Перезапустить игру</button>
    <button id="menu-button">Назад в меню (скоро)</button> <div id="game-over-overlay">
        <span id="game-over-message"></span>
        <button id="restart-game-over">Перезапустить</button>
    </div>

    <script type="module">
        import * as THREE from './js/three.module.js';
        import { OrbitControls } from './js/OrbitControls.js';
        import * as TWEEN from './js/tween.esm.js';

        // --- Глобальные переменные для Three.js ---
        let scene, camera, renderer, controls;
        let planet, cells = [];
        let raycaster, mouse;

        // --- Игровые переменные ---
        let board = [];
        const gridSize = 8; // 8x8 логических клеток на сфере
        const playerColors = [0xFF0000, 0x0000FF, 0x00FF00, 0xFFFF00, 0x9B59B6, 0x1ABC9C, 0xE67E22, 0xBDC3C7]; // HEX цвета
        let players = [];
        let currentPlayerIndex = 0;
        let gameActive = false;
        let animationQueue = Promise.resolve();
        const animationSpeed = 100; // ms between explosion steps

        // Пороги взрыва
        const THRESHOLDS = {
            corner: 2,
            edge: 3,
            center: 4
        };

        // --- Инициализация Three.js сцены ---
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Освещение
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            // Орбитальные контроллеры для вращения планеты
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05; // Сделаем вращение более плавным
            controls.screenSpacePanning = false;
            controls.maxPolarAngle = Math.PI; // Полный оборот по вертикали
            controls.enableZoom = true; // Включение зума
            controls.enablePan = false; // Отключаем панорамирование, чтобы не было конфликтов с кликами
            controls.target.set(0, 0, 0); // Фокус на центре планеты

            camera.position.z = 3; // Отдаляем камеру

            // Рейкастер для обнаружения кликов по 3D объектам
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Обработчики событий
            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('pointerdown', onPointerDown, false); // Для мобильных и ПК
            document.getElementById('restart-button').addEventListener('click', restartGame);
            document.getElementById('restart-game-over').addEventListener('click', restartGame);
            document.getElementById('menu-button').addEventListener('click', () => alert('Функция "Назад в меню" пока не реализована!')); // Заглушка

            startGame();
            animate();
        }

        // --- Управление размером окна ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            controls.update(); // Обновление контроллеров после изменения размера
        }

        // --- Игровой цикл ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            TWEEN.update(); // Обновление TWEEN анимаций
            renderer.render(scene, camera);
        }

        // --- Игровая логика ---

        function startGame() {
            // Скрыть оверлей "Игра окончена"
            document.getElementById('game-over-overlay').style.display = 'none';

            gameActive = true;
            // Очистка сцены от старых объектов
            if (planet) {
                scene.remove(planet);
                // Важно очищать геометрию и материалы, чтобы избежать утечек памяти
                planet.geometry.dispose();
                planet.material.dispose();
            }
            cells.forEach(cellObj => {
                // Если клетка является дочерней к планете, удаляем её через родителя
                if (planet && planet.children.includes(cellObj)) {
                    planet.remove(cellObj);
                } else {
                    scene.remove(cellObj);
                }
                if (cellObj.ballMesh) {
                    scene.remove(cellObj.ballMesh);
                    cellObj.ballMesh.geometry.dispose();
                    cellObj.ballMesh.material.dispose();
                }
                if (cellObj.geometry) cellObj.geometry.dispose();
                if (cellObj.material) cellObj.material.dispose();
            });
            cells = [];
            board = [];
            players = [];
            currentPlayerIndex = 0;
            animationQueue = Promise.resolve(); // Сброс очереди анимаций

            // Инициализация игроков (2-4 для начала, можно потом добавить настройку)
            const numPlayers = 4;
            for (let i = 0; i < numPlayers; i++) {
                players.push({
                    id: i,
                    color: playerColors[i],
                    cellsControlled: 0
                });
            }

            // Создание планеты
            const planetGeometry = new THREE.SphereGeometry(1.0, 32, 32); // Уменьшим радиус для лучшего обзора
            const planetMaterial = new THREE.MeshPhongMaterial({ color: 0x2c3e50, transparent: true, opacity: 0.8 });
            planet = new THREE.Mesh(planetGeometry, planetMaterial);
            scene.add(planet);

            // Создание "клеток" на поверхности сферы
            createSphericalGrid(gridSize);

            // Инициализация игрового состояния доски
            for (let i = 0; i < cells.length; i++) {
                board.push({ count: 0, owner: null });
                cells[i].userData.logicIndex = i; // Связь между 3D объектом и логическим состоянием
            }

            updatePlayerInfo();
            // Возвращаем камеру и фокус в начальное положение
            camera.position.set(0, 0, 3);
            controls.target.set(0, 0, 0);
            controls.update(); // Важно обновить контроллеры после изменения позиции камеры и таргета

            playSound('start');
        }

        // --- Функция для создания сетки на сфере (улучшенная) ---
        // Используем более плотные ячейки на полюсах, чтобы компенсировать искажения
        function createSphericalGrid(size) {
            const radius = 1.0;
            const cellScale = 0.18; // Размер отдельной "клетки"

            // Создаем простой материал для клеток, который будет меняться
            const cellBaseMaterial = new THREE.MeshPhongMaterial({ color: 0xaaaaaa, flatShading: true });

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    // Используем UV-развертку для создания более равномерной сетки
                    // `i` соответствует V-координате (широта), `j` соответствует U-координате (долгота)
                    const phi = (i / size) * Math.PI; // От 0 до PI (от полюса до полюса)
                    const theta = (j / size) * Math.PI * 2; // От 0 до 2*PI

                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.cos(phi);
                    const z = radius * Math.sin(phi) * Math.sin(theta);

                    // Создаем Mesh для клетки
                    // Можно использовать PlaneGeometry и ориентировать, или BoxGeometry для "квадратиков"
                    const cellGeometry = new THREE.PlaneGeometry(cellScale, cellScale); // Плоский квадратик
                    const cellMesh = new THREE.Mesh(cellGeometry, cellBaseMaterial.clone()); // Клонируем материал, чтобы менять цвет индивидуально

                    cellMesh.position.set(x, y, z);
                    // Ориентируем плоскость перпендикулярно радиусу сферы (lookAt(center) + rotateX(-PI/2) для PlaneGeometry)
                    cellMesh.lookAt(new THREE.Vector3(0, 0, 0)); // Смотрим на центр планеты
                    cellMesh.rotateX(Math.PI / 2); // Компенсируем ориентацию PlaneGeometry по умолчанию

                    cellMesh.userData = { row: i, col: j, id: cells.length };
                    cells.push(cellMesh);
                    planet.add(cellMesh); // Добавляем клетки как дочерние элементы планеты, чтобы они вращались вместе с ней
                }
            }
        }


        // --- Обработка кликов (Pointer Events для мобильных) ---
        let lastTapTime = 0;
        let tapPosition = new THREE.Vector2();

        function onPointerDown(event) {
            // Проверяем, что это не мультитач (чтобы избежать конфликтов с зумом/вращением)
            if (event.touches && event.touches.length > 1) {
                return;
            }

            // Запоминаем позицию касания/клика
            if (event.touches) {
                tapPosition.x = event.touches[0].clientX;
                tapPosition.y = event.touches[0].clientY;
            } else {
                tapPosition.x = event.clientX;
                tapPosition.y = event.clientY;
            }

            // Добавляем обработчик pointerup для определения завершения "тапа"
            renderer.domElement.addEventListener('pointerup', onPointerUp, { once: true });
        }

        function onPointerUp(event) {
            // Проверяем, что это не было "свайпом" (т.е. позиция отпускания близка к позиции касания)
            let currentX, currentY;
            if (event.changedTouches) {
                currentX = event.changedTouches[0].clientX;
                currentY = event.changedTouches[0].clientY;
            } else {
                currentX = event.clientX;
                currentY = event.clientY;
            }

            const threshold = 5; // Порог для определения "свайпа"
            if (Math.abs(tapPosition.x - currentX) > threshold || Math.abs(tapPosition.y - currentY) > threshold) {
                return; // Это был свайп (вращение), а не клик
            }

            // Если игра не активна или идут анимации, игнорируем клик
            if (!gameActive || animationQueue !== Promise.resolve()) {
                return;
            }

            // Нормализация координат мыши (от -1 до +1)
            mouse.x = (currentX / window.innerWidth) * 2 - 1;
            mouse.y = -(currentY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Получаем объекты, с которыми пересекся луч
            const intersects = raycaster.intersectObjects(cells);

            if (intersects.length > 0) {
                // intersected.object - это 3D-объект, который мы создали (Mesh)
                const clickedCellMesh = intersects[0].object;
                const cellId = clickedCellMesh.userData.logicIndex; // Используем logicIndex
                const r = clickedCellMesh.userData.row;
                const c = clickedCellMesh.userData.col;

                handleCellClick(r, c, cellId);
            }
        }


        function handleCellClick(r, c, cellId) {
            const cellLogic = board[cellId];
            const currentPlayer = players[currentPlayerIndex];

            if (cellLogic.owner === null || cellLogic.owner === currentPlayer.id) {
                // Если клетка заполнена и при нажатии должен быть взрыв
                // (если механика "нажать на раздутый шар и он разлетится")
                const neighborsCount = getNeighbors(r, c).length;
                let threshold = getThreshold(r, c); // Используем функцию getThreshold

                if (cellLogic.owner === currentPlayer.id && cellLogic.count === threshold) {
                    // Это тот случай, когда игрок "взрывает" свою полную клетку
                    animationQueue = animationQueue.then(() => forcedExplode(r, c, cellId, currentPlayer.id));
                } else {
                    // Обычное размещение шарика
                    placeBall(r, c, cellId, currentPlayer.id);
                    animationQueue = animationQueue.then(() => checkExplosions());
                }
            }
        }

        // --- Механика "принудительного" взрыва (по клику на заполненную клетку) ---
        function forcedExplode(r, c, cellId, playerId) {
            return new Promise(resolve => {
                const cellLogic = board[cellId];
                if (cellLogic.owner === playerId && cellLogic.count >= getThreshold(r, c)) {
                    // Вызываем прямой взрыв для этой клетки
                    processSingleExplosion(r, c, cellId).then(() => {
                        animationQueue = animationQueue.then(() => checkExplosions()); // Проверить, не вызвал ли форсированный взрыв новые цепные реакции
                        resolve();
                    });
                } else {
                    resolve(); // Если клетка не готова к взрыву, ничего не делаем
                }
            });
        }


        // --- Размещение шарика (3D) ---
        function placeBall(r, c, cellId, playerId) {
            const cellLogic = board[cellId];
            const cellMesh = cells[cellId];

            if (cellLogic.owner === null) {
                cellLogic.owner = playerId;
                players[playerId].cellsControlled++;
            }
            cellLogic.count++;
            playSound('place');

            // Удаляем старый шарик, если он был
            if (cellMesh.ballMesh) {
                scene.remove(cellMesh.ballMesh);
                cellMesh.ballMesh.geometry.dispose();
                cellMesh.ballMesh.material.dispose();
            }

            // Создаем новый 3D шарик соответствующего размера и цвета
            const maxBallSize = 0.1; // Максимальный размер шарика перед взрывом
            const minBallSize = 0.03; // Минимальный размер шарика
            const range = maxBallSize - minBallSize;
            const threshold = getThreshold(r, c);
            // Линейная интерполяция размера в зависимости от заполненности до порога
            const ballRadius = minBallSize + (cellLogic.count / threshold) * range;

            const ballGeometry = new THREE.SphereGeometry(ballRadius, 16, 16);
            const ballMaterial = new THREE.MeshPhongMaterial({ color: players[playerId].color, flatShading: true });
            const ballMesh = new THREE.Mesh(ballGeometry, ballMaterial);

            // Позиционируем шарик над клеткой, используя нормаль
            // Важно: position cellMesh.position находится в локальных координатах planet,
            // а ballMesh должен быть добавлен в scene, поэтому его позиция должна быть глобальной.
            // Получаем глобальную позицию клетки
            const cellGlobalPos = new THREE.Vector3();
            cellMesh.getWorldPosition(cellGlobalPos);

            const normal = cellGlobalPos.clone().normalize(); // Вектор от центра планеты до клетки
            // Учитываем радиус планеты + небольшое смещение + половину радиуса шарика
            ballMesh.position.copy(normal.multiplyScalar(planet.geometry.parameters.radius + 0.02 + ballRadius / 2));
            ballMesh.lookAt(new THREE.Vector3(0,0,0)); // Ориентируем шарик, чтобы его "верх" смотрел от центра планеты

            cellMesh.ballMesh = ballMesh; // Сохраняем ссылку на шарик в userData клетки
            scene.add(ballMesh);

            // Анимация появления шарика
            ballMesh.scale.set(0.1, 0.1, 0.1);
            new TWEEN.Tween(ballMesh.scale)
                .to({ x: 1, y: 1, z: 1 }, 200)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();

            updateCellUI(cellId);
            checkWinCondition(); // Проверка условия победы после каждого хода
        }

        // --- Обновление UI для клетки (цвет фона клетки и шарика) ---
        function updateCellUI(cellId) {
            const cellLogic = board[cellId];
            const cellMesh = cells[cellId];

            if (cellLogic.owner !== null) {
                cellMesh.material.color.set(players[cellLogic.owner].color);
                cellMesh.material.opacity = 0.4; // Легкий оттенок
            } else {
                cellMesh.material.color.set(0xaaaaaa); // Нейтральный цвет
                cellMesh.material.opacity = 1;
            }
            cellMesh.material.needsUpdate = true; // Важно для обновления материала
        }


        // --- Логика взрывов (асинхронная) ---
        function checkExplosions() {
            return new Promise(resolve => {
                const cellsToExplode = [];
                for (let i = 0; i < board.length; i++) {
                    const cellLogic = board[i];
                    const r = cells[i].userData.row;
                    const c = cells[i].userData.col;
                    if (cellLogic.owner !== null && cellLogic.count >= getThreshold(r, c)) {
                        cellsToExplode.push({ id: i, r: r, c: c });
                    }
                }

                if (cellsToExplode.length > 0) {
                    playSound('explode');

                    const explosionPromises = cellsToExplode.map(({ id, r, c }) => processSingleExplosion(r, c, id));

                    Promise.all(explosionPromises).then(() => {
                        // После обработки всех взрывов в этой волне, проверяем условия победы
                        checkWinCondition();
                        // Планируем следующий шаг цепной реакции (или переход хода)
                        setTimeout(() => {
                            animationQueue = animationQueue.then(() => checkExplosions());
                            resolve();
                        }, animationSpeed);
                    });
                } else {
                    // Нет больше взрывов, передаем ход
                    nextTurn();
                    resolve();
                }
            });
        }

        // Обработка одного взрыва
        function processSingleExplosion(r, c, id) {
            return new Promise(resolve => {
                const cellLogic = board[id];
                const cellMesh = cells[id];
                const owner = cellLogic.owner;
                const ownerColor = players[owner].color;

                const numExplodingBalls = cellLogic.count; // Количество шариков для разлета
                cellLogic.count = 0; // Сбрасываем счетчик взорвавшейся клетки
                if (cellLogic.owner !== null) {
                    players[cellLogic.owner].cellsControlled--; // Клетка теряет владельца
                    cellLogic.owner = null;
                }
                updateCellUI(id); // Обновляем UI, чтобы показать пустую клетку

                // Анимация разлета шариков
                if (cellMesh.ballMesh) {
                    scene.remove(cellMesh.ballMesh);
                    cellMesh.ballMesh.geometry.dispose();
                    cellMesh.ballMesh.material.dispose();
                    cellMesh.ballMesh = null;
                }

                const explosionGroup = new THREE.Group();
                scene.add(explosionGroup);

                const neighbors = getNeighbors(r, c);
                let completedAnimations = 0;

                // Учитываем количество шариков, которые разлетаются *и* те, что летят к соседям
                // Если шариков больше чем соседей, то "лишние" просто разлетаются
                const totalBallsToAnimate = Math.max(numExplodingBalls, neighbors.length);
                if (totalBallsToAnimate === 0) { // Если нечего анимировать (такое не должно быть при взрыве)
                    resolve();
                    return;
                }

                // Анимация разлета "лишних" шариков (если есть)
                for (let i = 0; i < numExplodingBalls; i++) { // Анимируем все шарики, некоторые полетят к соседям, некоторые просто разлетятся
                    const smallBallGeometry = new THREE.SphereGeometry(0.02, 8, 8);
                    const smallBallMaterial = new THREE.MeshPhongMaterial({ color: ownerColor });
                    const smallBallMesh = new THREE.Mesh(smallBallGeometry, smallBallMaterial);

                    const startPos = new THREE.Vector3();
                    cellMesh.getWorldPosition(startPos); // Получаем глобальную позицию клетки

                    smallBallMesh.position.copy(startPos);

                    if (i < neighbors.length) {
                        // Этот шарик летит к соседу
                        const neighborCoords = neighbors[i];
                        let neighborId = -1;
                        for (let k = 0; k < cells.length; k++) {
                            if (cells[k].userData.row === neighborCoords[0] && cells[k].userData.col === neighborCoords[1]) {
                                neighborId = k;
                                break;
                            }
                        }
                        if (neighborId !== -1) {
                            const neighborLogic = board[neighborId];
                            const neighborMesh = cells[neighborId];

                            // Изменяем владение и счетчик для соседа
                            if (neighborLogic.owner !== owner && neighborLogic.owner !== null) {
                                players[neighborLogic.owner].cellsControlled--;
                            }
                            if (neighborLogic.owner !== owner || neighborLogic.owner === null) {
                                neighborLogic.owner = owner;
                                players[owner].cellsControlled++;
                            }
                            neighborLogic.count++;

                            const endPosition = new THREE.Vector3();
                            neighborMesh.getWorldPosition(endPosition); // Глобальная позиция соседа

                            scene.add(flyingBallMesh); // Добавляем в сцену, так как flyingBallMesh будет двигаться относительно сцены

                            new TWEEN.Tween(smallBallMesh.position)
                                .to(endPosition, 200)
                                .easing(TWEEN.Easing.Quadratic.In)
                                .onComplete(() => {
                                    scene.remove(smallBallMesh);
                                    smallBallMesh.geometry.dispose();
                                    smallBallMesh.material.dispose();
                                    placeBallAfterExplosion(neighborId, owner); // Обновить шарик в клетке соседа
                                    completedAnimations++;
                                    if (completedAnimations >= totalBallsToAnimate) {
                                        scene.remove(explosionGroup);
                                        resolve();
                                    }
                                })
                                .start();
                        } else {
                            // Сосед не найден, просто разлетается
                            const direction = new THREE.Vector3(
                                Math.random() * 2 - 1,
                                Math.random() * 2 - 1,
                                Math.random() * 2 - 1
                            ).normalize();
                            const endPos = startPos.clone().add(direction.multiplyScalar(0.3 + Math.random() * 0.3));

                            scene.add(smallBallMesh);

                            new TWEEN.Tween(smallBallMesh.position)
                                .to(endPos, 250 + Math.random() * 150)
                                .easing(TWEEN.Easing.Quadratic.Out)
                                .onComplete(() => {
                                    scene.remove(smallBallMesh);
                                    smallBallMesh.geometry.dispose();
                                    smallBallMesh.material.dispose();
                                    completedAnimations++;
                                    if (completedAnimations >= totalBallsToAnimate) {
                                        scene.remove(explosionGroup);
                                        resolve();
                                    }
                                })
                                .start();
                        }
                    } else {
                        // Этот шарик просто разлетается (их больше, чем соседей)
                        const direction = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            Math.random() * 2 - 1,
                            Math.random() * 2 - 1
                        ).normalize();
                        const endPos = startPos.clone().add(direction.multiplyScalar(0.3 + Math.random() * 0.3));

                        scene.add(smallBallMesh);

                        new TWEEN.Tween(smallBallMesh.position)
                            .to(endPos, 250 + Math.random() * 150)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .onComplete(() => {
                                scene.remove(smallBallMesh);
                                smallBallMesh.geometry.dispose();
                                smallBallMesh.material.dispose();
                                completedAnimations++;
                                if (completedAnimations >= totalBallsToAnimate) {
                                    scene.remove(explosionGroup);
                                    resolve();
                                }
                            })
                            .start();
                    }
                }
            });
        }


        // Вспомогательная функция для обновления шарика в клетке после прилета
        function placeBallAfterExplosion(cellId, playerId) {
            const cellLogic = board[cellId];
            const cellMesh = cells[cellId];

            if (cellMesh.ballMesh) {
                scene.remove(cellMesh.ballMesh);
                cellMesh.ballMesh.geometry.dispose();
                cellMesh.ballMesh.material.dispose();
            }

            const threshold = getThreshold(cellMesh.userData.row, cellMesh.userData.col);

            const maxBallSize = 0.1;
            const minBallSize = 0.03;
            const range = maxBallSize - minBallSize;
            const ballRadius = minBallSize + (cellLogic.count / threshold) * range;

            const ballGeometry = new THREE.SphereGeometry(ballRadius, 16, 16);
            const ballMaterial = new THREE.MeshPhongMaterial({ color: players[playerId].color, flatShading: true });
            const ballMesh = new THREE.Mesh(ballGeometry, ballMaterial);

            // Получаем глобальную позицию клетки
            const cellGlobalPos = new THREE.Vector3();
            cellMesh.getWorldPosition(cellGlobalPos);

            const normal = cellGlobalPos.clone().normalize();
            ballMesh.position.copy(normal.multiplyScalar(planet.geometry.parameters.radius + 0.02 + ballRadius / 2));
            ballMesh.lookAt(new THREE.Vector3(0,0,0));

            cellMesh.ballMesh = ballMesh;
            scene.add(ballMesh);

            ballMesh.scale.set(0.1, 0.1, 0.1);
            new TWEEN.Tween(ballMesh.scale)
                .to({ x: 1, y: 1, z: 1 }, 150)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();

            updateCellUI(cellId);
        }

        function getThreshold(r, c) {
            const neighbors = getNeighbors(r, c); // Определяем количество соседей
            const numNeighbors = neighbors.length;

            if (numNeighbors <= 2) { // Для "полюсов" или крайних точек
                return THRESHOLDS.corner;
            } else if (numNeighbors === 3) { // Для "краев"
                return THRESHOLDS.edge;
            } else { // Для "центров"
                return THRESHOLDS.center;
            }
        }


        // --- Определение соседей на сферической сетке (улучшенная) ---
        // Эта функция пытается найти соседей в "прямоугольной" сетке.
        // Для полюсов (row 0 и row gridSize-1) соседи будут отличаться.
        function getNeighbors(r, c) {
            const neighbors = [];
            const dr = [-1, 1, 0, 0];
            const dc = [0, 0, -1, 1];

            for (let i = 0; i < 4; i++) {
                let nr = r + dr[i];
                let nc = c + dc[i];

                // Обработка "заворачивания" по горизонтали (долготе)
                if (nc < 0) nc = gridSize - 1;
                if (nc >= gridSize) nc = 0;

                // Обработка "полюсов" (широты):
                // Если мы на верхнем полюсе (r=0), то "соседом" вверх будет вся нижняя "полоса"
                // Если мы на нижнем полюсе (r=gridSize-1), то "соседом" вниз будет вся верхняя "полоса"
                // Это сильно упрощено для прямоугольной проекции на сфере
                if (nr === -1) { // Сдвиг вверх от r=0
                    // Все клетки в последней строке (gridSize-1) являются "соседями"
                    // В реальной геосфере это было бы одной точкой
                    for(let k=0; k < gridSize; k++) {
                         neighbors.push([gridSize - 1, k]);
                    }
                    continue;
                } else if (nr === gridSize) { // Сдвиг вниз от r=gridSize-1
                    // Все клетки в первой строке (0) являются "соседями"
                    for(let k=0; k < gridSize; k++) {
                        neighbors.push([0, k]);
                    }
                    continue;
                }

                if (nr >= 0 && nr < gridSize) {
                     neighbors.push([nr, nc]);
                }
            }
            // Удаляем дубликаты, если они появились (например, при обработке полюсов)
            const uniqueNeighbors = [];
            const seen = new Set();
            neighbors.forEach(n => {
                const key = `${n[0]},${n[1]}`;
                if (!seen.has(key)) {
                    uniqueNeighbors.push(n);
                    seen.add(key);
                }
            });
            return uniqueNeighbors;
        }


        // --- Передача хода и проверка победы ---
        function nextTurn() {
            let nextPlayerIndex = currentPlayerIndex;
            let foundNextPlayer = false;
            for (let i = 1; i <= players.length; i++) {
                nextPlayerIndex = (currentPlayerIndex + i) % players.length;
                if (players[nextPlayerIndex].cellsControlled > 0 || countPlayerBalls(nextPlayerIndex) > 0) {
                    foundNextPlayer = true;
                    break;
                }
            }

            if (foundNextPlayer) {
                currentPlayerIndex = nextPlayerIndex;
                updatePlayerInfo();
            } else {
                endGame(); // Если активных игроков нет, игра окончена
            }
        }

        function countPlayerBalls(playerId) {
            let count = 0;
            for (let i = 0; i < board.length; i++) {
                if (board[i].owner === playerId) {
                    count += board[i].count;
                }
            }
            return count;
        }

        function checkWinCondition() {
            let activePlayers = players.filter(player => player.cellsControlled > 0 || countPlayerBalls(player.id) > 0);

            if (activePlayers.length === 1 && gameActive) {
                endGame(activePlayers[0]);
            } else if (activePlayers.length === 0) {
                // Если все игроки выбыли (ничья, или ошибка в логике)
                endGame(null);
            }
        }

        function endGame(winner = null) {
            gameActive = false;
            let message = 'Игра окончена!';
            let sound = 'lose';
            if (winner) {
                message = `Игрок ${winner.id + 1} победил!`;
                sound = 'win';
            }
            document.getElementById('game-over-message').textContent = message;
            document.getElementById('game-over-overlay').style.display = 'flex';
            playSound(sound);
        }

        // --- Обновление UI игрока ---
        function updatePlayerInfo() {
            document.getElementById('current-player-text').textContent = `Игрок ${currentPlayerIndex + 1}`;

            // Обновление цвета для каждого игрока в инфо-панели
            players.forEach(player => {
                const playerColorDot = document.getElementById(`player-color-${player.id}`);
                if (playerColorDot) {
                    // Конвертируем числовой HEX в CSS HEX строку
                    playerColorDot.style.backgroundColor = `#${player.color.toString(16).padStart(6, '0')}`;
                    playerColorDot.style.boxShadow = `0 0 8px #${player.color.toString(16).padStart(6, '0')}`;
                }
            });
            // Выделить текущего игрока
            document.querySelectorAll('.player-status-info').forEach((el, idx) => {
                if (idx === currentPlayerIndex) {
                    el.style.fontWeight = 'bold';
                    el.style.transform = 'scale(1.1)';
                    el.style.color = 'white';
                } else {
                    el.style.fontWeight = 'normal';
                    el.style.transform = 'scale(1.0)';
                    el.style.color = 'rgba(255,255,255,0.7)';
                }
            });
        }

        // --- Звуки (из вашей предыдущей версии) ---
        function playSound(type) {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);

                gainNode.gain.setValueAtTime(0.05, ctx.currentTime);

                switch (type) {
                    case 'place':
                        oscillator.type = 'sine';
                        oscillator.frequency.value = 800;
                        gainNode.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 0.1);
                        break;
                    case 'explode':
                        oscillator.type = 'square';
                        oscillator.frequency.value = 200;
                        gainNode.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 0.3);
                        break;
                    case 'start':
                        oscillator.type = 'triangle';
                        oscillator.frequency.value = 523.25;
                        gainNode.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 0.8);
                        break;
                    case 'win':
                        oscillator.type = 'sine';
                        oscillator.frequency.value = 1046.50;
                        gainNode.gain.setValueAtTime(0.1, ctx.currentTime);
                        gainNode.gain.linearRampToValueAtTime(0.00001, ctx.currentTime + 1.0);
                        break;
                    case 'lose':
                        oscillator.type = 'triangle';
                        oscillator.frequency.value = 110.00;
                        gainNode.gain.setValueAtTime(0.1, ctx.currentTime);
                        gainNode.gain.linearRampToValueAtTime(0.00001, ctx.currentTime + 1.0);
                        break;
                    default:
                        oscillator.stop();
                        return;
                }

                oscillator.start();
                oscillator.stop(ctx.currentTime + 0.8);
            } catch (e) {
                console.log('Web Audio API не поддерживается или произошла ошибка при воспроизведении звука:', e);
            }
        }

        // --- Инициализация игры при загрузке страницы ---
        window.onload = init;

    </script>
</body>
</html>