<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Цепная реакция 3D: Планета</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
            touch-action: none; /* Предотвращает прокрутку страницы на мобильных */
        }
        canvas {
            display: block;
            touch-action: none; /* Важно для мобильных устройств */
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 1.2em;
            background: rgba(0,0,0,0.6);
            padding: 10px 15px;
            border-radius: 8px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 150px;
        }
        .player-status-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .player-status-dot {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(255,255,255,0.5);
        }
        .active-player-dot {
            border: 3px solid yellow; /* Обводка для активного игрока */
            box-shadow: 0 0 10px yellow; /* Сияние для активного игрока */
        }
        #restart-button {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 25px;
            font-size: 1.2em;
            background-color: #4CAF50; /* Зеленая кнопка */
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: background-color 0.3s ease, transform 0.2s ease;
            z-index: 100;
            display: none; /* Скрыта по умолчанию */
        }
        #restart-button:hover {
            background-color: #45a049;
            transform: translateX(-50%) scale(1.05);
        }
        #player-count-input-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            color: white;
            z-index: 200;
            box-shadow: 0 0 20px rgba(0,255,255,0.5);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        #player-count-input-container label {
            font-size: 1.5em;
            margin-bottom: 10px;
            text-shadow: 0 0 5px cyan;
        }
        #player-count-input {
            width: 80px;
            padding: 10px;
            font-size: 1.2em;
            border-radius: 5px;
            border: 1px solid #333;
            background-color: #222;
            color: white;
            text-align: center;
        }
        #start-game-button {
            padding: 15px 30px;
            font-size: 1.3em;
            background-color: #007BFF; /* Синяя кнопка */
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 5px 10px rgba(0,0,0,0.4);
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        #start-game-button:hover {
            background-color: #0056b3;
            transform: scale(1.05);
        }
        .message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            font-size: 3em;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.8);
            z-index: 1000;
            pointer-events: none; /* Пропускает клики */
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        .message-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .message-overlay span {
            margin-bottom: 20px;
        }
        .message-overlay button {
            padding: 15px 30px;
            font-size: 1.5em;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            pointer-events: auto; /* Включаем клики для кнопки */
        }
        .message-overlay button:hover {
            background-color: #5a6268;
        }
    </style>
</head>
<body>
    <div id="info"></div>
    <button id="restart-button">Начать заново</button>

    <div id="player-count-input-container">
        <label for="player-count-input">Количество игроков (2-6):</label>
        <input type="number" id="player-count-input" value="2" min="2" max="6">
        <button id="start-game-button">Начать игру</button>
    </div>

    <div id="message-overlay" class="message-overlay">
        <span id="overlay-text"></span>
        <button id="overlay-restart-button">Начать заново</button>
    </div>

    <script type="module">
        // --- Импорт библиотек Three.js, OrbitControls и TWEEN из CDN ---
        import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js';
        import * as TWEEN from 'https://unpkg.com/@tweenjs/tween.js@21.0.0/dist/tween.esm.js';

        // --- Основные параметры Three.js ---
        let scene, camera, renderer, controls;
        let planetMesh, cells = [], cellObjects = [];
        const pointer = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        let currentIntersected = null; // Для отслеживания подсвеченной ячейки
        const playerColors = [
            0xff0000, // Красный (Player 1)
            0x00ff00, // Зеленый (Player 2)
            0x0000ff, // Синий (Player 3)
            0xffff00, // Желтый (Player 4)
            0xff00ff, // Пурпурный (Player 5)
            0x00ffff  // Голубой (Player 6)
        ];
        const CELL_RADIUS = 0.5; // Радиус сферы-ячейки
        const SPHERE_RADIUS = 5; // Радиус главной сферы
        const CELL_CAPACITY = 4; // Количество шаров для взрыва
        const ANIMATION_DURATION = 200; // Продолжительность анимации в ms
        const EXPLOSION_SCALE_FACTOR = 1.5; // Насколько увеличивается ячейка при взрыве

        // --- Переменные состояния игры ---
        let players = [];
        let currentPlayerIndex = 0;
        let gameActive = false;
        let numPlayers = 2; // Количество игроков по умолчанию

        // --- UI элементы ---
        const infoPanel = document.getElementById('info');
        const restartButton = document.getElementById('restart-button');
        const playerCountInputContainer = document.getElementById('player-count-input-container');
        const playerCountInput = document.getElementById('player-count-input');
        const startGameButton = document.getElementById('start-game-button');
        const messageOverlay = document.getElementById('message-overlay');
        const overlayText = document.getElementById('overlay-text');
        const overlayRestartButton = document.getElementById('overlay-restart-button');

        // --- Звуки ---
        function playSound(type) {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);

                switch (type) {
                    case 'place':
                        oscillator.type = 'sine';
                        oscillator.frequency.value = 800;
                        gainNode.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 0.3);
                        break;
                    case 'explode':
                        oscillator.type = 'square';
                        oscillator.frequency.value = 200;
                        gainNode.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 0.5);
                        break;
                    case 'win':
                        oscillator.type = 'sine';
                        oscillator.frequency.value = 1046.50; // High C
                        gainNode.gain.setValueAtTime(0.1, ctx.currentTime);
                        gainNode.gain.linearRampToValueAtTime(0.1, ctx.currentTime + 0.2);
                        gainNode.gain.linearRampToValueAtTime(0.00001, ctx.currentTime + 1.0);
                        break;
                    case 'lose':
                        oscillator.type = 'triangle';
                        oscillator.frequency.value = 110.00; // Low A
                        gainNode.gain.setValueAtTime(0.1, ctx.currentTime);
                        gainNode.gain.linearRampToValueAtTime(0.00001, ctx.currentTime + 1.0);
                        break;
                    default:
                        oscillator.stop();
                        return;
                }

                oscillator.start();
                oscillator.stop(ctx.currentTime + 0.8);
            } catch (e) {
                console.log('Web Audio API не поддерживается или произошла ошибка при воспроизведении звука:', e);
            }
        }

        // --- Инициализация сцены Three.js ---
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510); // Темный фон

            // Камера
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = SPHERE_RADIUS * 2; // Камера подальше от сферы

            // Рендерер
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // Для четкости на HiDPI экранах
            document.body.appendChild(renderer.domElement);

            // Свет
            const ambientLight = new THREE.AmbientLight(0x404040, 5); // Мягкий рассеянный свет
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 3); // Направленный свет
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Управление камерой
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = SPHERE_RADIUS * 1.2; // Чтобы не проникать внутрь сферы
            controls.maxDistance = SPHERE_RADIUS * 4; // Чтобы не улетать слишком далеко

            // Добавляем обработчик событий мыши/касания
            renderer.domElement.addEventListener('pointermove', onPointerMove);
            renderer.domElement.addEventListener('pointerdown', onPointerDown);

            // Обработка изменения размера окна
            window.addEventListener('resize', onWindowResize);

            // Главный цикл анимации
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update(); // Обновление твинов для анимации
            controls.update(); // Обновление управления камерой
            renderer.render(scene, camera);
        }

        // --- Логика игры ---

        class Cell {
            constructor(id, position, neighbors) {
                this.id = id;
                this.position = position; // THREE.Vector3
                this.owner = null; // null или id игрока
                this.balls = 0; // Количество шаров в ячейке
                this.neighbors = neighbors; // Массив id соседних ячеек
                this.object = null; // THREE.Mesh для визуализации ячейки
                this.ballObjects = []; // Массив THREE.Mesh для визуализации шаров
            }

            // Добавляет шар в ячейку
            addBall(player) {
                if (this.owner === null || this.owner === player.id) {
                    this.owner = player.id;
                    this.balls++;
                    this.updateVisuals(player.color);
                    this.addBallVisual(player.color);
                } else {
                    // Ячейка захвачена противником
                    this.balls--;
                    if (this.balls < 0) {
                        this.owner = player.id;
                        this.balls = Math.abs(this.balls);
                        this.updateVisuals(player.color);
                    }
                    this.removeBallVisual();
                }
                playSound('place');

                if (this.balls >= CELL_CAPACITY && this.owner === player.id) {
                    // Задержка перед взрывом для анимации добавления шара
                    setTimeout(() => this.explode(player), ANIMATION_DURATION + 50);
                }
            }

            // Обновляет визуальное представление ячейки
            updateVisuals(color = 0x333333) {
                if (!this.object) return;
                const material = this.object.material;
                new TWEEN.Tween(material.color)
                    .to(new THREE.Color(color), ANIMATION_DURATION)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                this.object.userData.ownerId = this.owner; // Сохраняем ID владельца для рейкастинга
            }

            // Добавляет визуальный шар в ячейку
            addBallVisual(color) {
                const ballGeometry = new THREE.SphereGeometry(CELL_RADIUS / 4, 8, 8);
                const ballMaterial = new THREE.MeshBasicMaterial({ color: color });
                const ballMesh = new THREE.Mesh(ballGeometry, ballMaterial);
                ballMesh.position.copy(this.position);
                ballMesh.scale.set(0.1, 0.1, 0.1); // Начинаем маленьким
                scene.add(ballMesh);
                this.ballObjects.push(ballMesh);

                // Анимируем появление шара и его расположение
                const offset = new THREE.Vector3().copy(this.position).normalize().multiplyScalar(CELL_RADIUS * 0.5);
                const targetPosition = new THREE.Vector3().copy(this.position).add(offset); // чуть выше центра

                new TWEEN.Tween(ballMesh.scale)
                    .to({ x: 1, y: 1, z: 1 }, ANIMATION_DURATION)
                    .easing(TWEEN.Easing.Back.Out)
                    .start();

                new TWEEN.Tween(ballMesh.position)
                    .to(targetPosition, ANIMATION_DURATION)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .onUpdate(() => {
                        // Распределение шаров вокруг ячейки
                        const count = this.ballObjects.length;
                        const angle = (Math.PI * 2) / count;
                        this.ballObjects.forEach((ball, i) => {
                            const offsetAngle = angle * i;
                            const xOffset = Math.cos(offsetAngle) * CELL_RADIUS * 0.3;
                            const zOffset = Math.sin(offsetAngle) * CELL_RADIUS * 0.3;
                            const upVector = new THREE.Vector3().copy(this.position).normalize();
                            const rightVector = new THREE.Vector3().crossVectors(upVector, camera.up).normalize();
                            const forwardVector = new THREE.Vector3().crossVectors(rightVector, upVector).normalize();

                            const finalOffset = rightVector.multiplyScalar(xOffset).add(forwardVector.multiplyScalar(zOffset)).add(upVector.multiplyScalar(CELL_RADIUS * 0.3));
                            ball.position.copy(this.position).add(finalOffset);
                        });
                    })
                    .start();
            }

            // Удаляет визуальный шар из ячейки
            removeBallVisual() {
                if (this.ballObjects.length > 0) {
                    const ballMesh = this.ballObjects.pop();
                    new TWEEN.Tween(ballMesh.scale)
                        .to({ x: 0.1, y: 0.1, z: 0.1 }, ANIMATION_DURATION)
                        .easing(TWEEN.Easing.Quadratic.In)
                        .onComplete(() => {
                            scene.remove(ballMesh);
                            ballMesh.geometry.dispose();
                            ballMesh.material.dispose();
                        })
                        .start();
                }
            }

            // Взрыв ячейки
            explode(player) {
                playSound('explode');
                this.balls = 0; // Сбрасываем шары в текущей ячейке

                // Анимация взрыва: увеличение и уменьшение
                const originalScale = this.object.scale.clone();
                new TWEEN.Tween(this.object.scale)
                    .to({
                        x: originalScale.x * EXPLOSION_SCALE_FACTOR,
                        y: originalScale.y * EXPLOSION_SCALE_FACTOR,
                        z: originalScale.z * EXPLOSION_SCALE_FACTOR
                    }, ANIMATION_DURATION / 2)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .onComplete(() => {
                        new TWEEN.Tween(this.object.scale)
                            .to(originalScale, ANIMATION_DURATION / 2)
                            .easing(TWEEN.Easing.Quadratic.In)
                            .start();
                    })
                    .start();

                // Удаляем все визуальные шары
                this.ballObjects.forEach(ball => {
                    new TWEEN.Tween(ball.scale)
                        .to({ x: 0, y: 0, z: 0 }, ANIMATION_DURATION)
                        .easing(TWEEN.Easing.Quadratic.In)
                        .onComplete(() => {
                            scene.remove(ball);
                            ball.geometry.dispose();
                            ball.material.dispose();
                        })
                        .start();
                });
                this.ballObjects = []; // Очищаем массив после анимации

                // Распространение взрыва на соседей
                this.neighbors.forEach(neighborId => {
                    const neighborCell = cells.find(c => c.id === neighborId);
                    if (neighborCell) {
                        neighborCell.addBall(player);
                    }
                });

                this.updateVisuals(player.color); // Обновляем цвет ячейки после взрыва

                // Проверяем победителя после распространения взрыва
                setTimeout(checkWinCondition, ANIMATION_DURATION + 100);
            }
        }

        // --- Управление игрой ---

        function initGame() {
            // Сброс состояния
            cells = [];
            cellObjects = [];
            players = [];
            currentPlayerIndex = 0;
            gameActive = true;
            infoPanel.innerHTML = '';
            restartButton.style.display = 'none';
            messageOverlay.classList.remove('visible');
            overlayRestartButton.removeEventListener('click', initGame);
            overlayRestartButton.addEventListener('click', initGame); // Для кнопки в оверлее

            // Удаляем старые объекты из сцены
            if (planetMesh) {
                scene.remove(planetMesh);
                planetMesh.geometry.dispose();
                planetMesh.material.dispose();
            }
            cellObjects.forEach(obj => {
                scene.remove(obj);
                obj.geometry.dispose();
                obj.material.dispose();
            });
            // Удаляем все шары
            scene.children.filter(obj => obj.name === 'ball').forEach(ball => scene.remove(ball));


            // Создание игроков
            for (let i = 0; i < numPlayers; i++) {
                players.push({
                    id: i,
                    color: playerColors[i],
                    active: true // Все игроки активны в начале
                });
            }

            // Создание 3D сферы (планеты)
            const sphereGeometry = new THREE.SphereGeometry(SPHERE_RADIUS, 32, 32);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: 0x8888aa, // Серый базовый цвет планеты
                transparent: true,
                opacity: 0.8,
                specular: 0x555555,
                shininess: 30
            });
            planetMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
            scene.add(planetMesh);

            // Генерация ячеек на поверхности сферы (примерно равномерно)
            const numCells = 150; // Количество ячеек на планете
            const tempPositions = [];
            for (let i = 0; i < numCells; i++) {
                const phi = Math.acos(1 - 2 * Math.random());
                const theta = 2 * Math.PI * Math.random();
                const x = SPHERE_RADIUS * Math.sin(phi) * Math.cos(theta);
                const y = SPHERE_RADIUS * Math.sin(phi) * Math.sin(theta);
                const z = SPHERE_RADIUS * Math.cos(phi);
                tempPositions.push(new THREE.Vector3(x, y, z));
            }

            // Создаем объекты Cell и их визуализации
            const cellGeometry = new THREE.SphereGeometry(CELL_RADIUS, 16, 16);
            const baseCellMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 }); // Базовый серый цвет

            tempPositions.forEach((pos, index) => {
                const cellMesh = new THREE.Mesh(cellGeometry, baseCellMaterial.clone()); // Клонируем материал для каждой ячейки
                cellMesh.position.copy(pos);
                cellMesh.userData.id = index; // Сохраняем ID для рейкастинга
                scene.add(cellMesh);
                cellObjects.push(cellMesh); // Добавляем в массив для рейкастинга

                // Поиск соседей для каждой ячейки
                const neighbors = [];
                tempPositions.forEach((otherPos, otherIndex) => {
                    if (index !== otherIndex && pos.distanceTo(otherPos) < CELL_RADIUS * 3) { // Радиус поиска соседей
                        neighbors.push(otherIndex);
                    }
                });
                cells.push(new Cell(index, pos, neighbors));
                cells[index].object = cellMesh; // Привязываем THREE.Mesh к объекту Cell
            });

            // Инициализация стартовых позиций для игроков (по 1 ячейке)
            players.forEach((player, index) => {
                let startCellId;
                do {
                    startCellId = Math.floor(Math.random() * cells.length);
                } while (cells[startCellId].owner !== null); // Ищем свободную ячейку

                cells[startCellId].owner = player.id;
                cells[startCellId].balls = 1;
                cells[startCellId].updateVisuals(player.color);
                cells[startCellId].addBallVisual(player.color); // Добавляем визуальный шар
            });

            updateInfoPanel();
            highlightCurrentPlayer();
        }

        function switchPlayer() {
            let nextPlayerFound = false;
            let originalPlayerIndex = currentPlayerIndex;
            do {
                currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
                if (players[currentPlayerIndex].active) {
                    nextPlayerFound = true;
                }
                // Если мы прошли полный круг и не нашли активного игрока, прерываем цикл (остался один игрок)
                if (currentPlayerIndex === originalPlayerIndex && !players[currentPlayerIndex].active && players.filter(p => p.active).length > 1) {
                     // Если остался только один активный игрок (победитель), то игра должна быть завершена
                     // Если активных игроков больше одного, но мы прошли круг, значит, не было хода
                     // Эту ветку можно использовать для отладки, но в идеале, игра должна завершиться раньше.
                    break;
                }
            } while (!players[currentPlayerIndex].active);

            // Если остался только один активный игрок, игра должна завершиться
            if (players.filter(p => p.active).length <= 1) {
                checkWinCondition();
                return;
            }

            highlightCurrentPlayer();
            updateInfoPanel();
        }

        function highlightCurrentPlayer() {
            players.forEach((player, i) => {
                const playerDot = document.getElementById(`player-dot-${player.id}`);
                if (playerDot) {
                    if (i === currentPlayerIndex) {
                        playerDot.classList.add('active-player-dot');
                    } else {
                        playerDot.classList.remove('active-player-dot');
                    }
                }
            });
        }


        function updateInfoPanel() {
            infoPanel.innerHTML = '';
            let activePlayersCount = 0;
            players.forEach(player => {
                const ownedCells = cells.filter(cell => cell.owner === player.id).length;
                const totalBalls = cells.filter(cell => cell.owner === player.id).reduce((sum, cell) => sum + cell.balls, 0);

                if (ownedCells > 0) { // Игрок считается активным, если у него есть хотя бы одна ячейка
                    player.active = true;
                    activePlayersCount++;
                } else {
                    player.active = false;
                    playSound('lose'); // Звук проигрыша для выбывшего игрока
                }

                const playerStatusDiv = document.createElement('div');
                playerStatusDiv.className = 'player-status-info';
                playerStatusDiv.id = `player-status-${player.id}`;
                playerStatusDiv.innerHTML = `
                    <div class="player-status-dot" id="player-dot-${player.id}" style="background-color: #${player.color.toString(16).padStart(6, '0')};"></div>
                    <span>Игрок ${player.id + 1}: Ячеек: ${ownedCells} | Шаров: ${totalBalls}</span>
                `;
                if (!player.active) {
                    playerStatusDiv.style.opacity = 0.5; // Сделать выбывших игроков менее заметными
                }
                infoPanel.appendChild(playerStatusDiv);
            });

            highlightCurrentPlayer(); // Обновляем подсветку активного игрока
        }


        function checkWinCondition() {
            updateInfoPanel(); // Обновляем состояние игроков
            const activePlayers = players.filter(p => p.active);

            if (activePlayers.length <= 1 && gameActive) {
                gameActive = false;
                if (activePlayers.length === 1) {
                    const winnerPlayer = activePlayers[0];
                    showOverlay(`Игрок ${winnerPlayer.id + 1} победил!`, winnerPlayer.color);
                    playSound('win');
                } else {
                    // Если activePlayers.length === 0, это ничья или все выбыли (очень редкий случай)
                    showOverlay('Ничья!', 0x888888); // Серый цвет для ничьей
                }
                restartButton.style.display = 'block'; // Показываем кнопку перезапуска
                overlayRestartButton.style.display = 'block';
            }
        }

        // --- Обработчики событий ---
        function onPointerMove(event) {
            if (!gameActive) {
                if (currentIntersected) {
                    currentIntersected.object.material.emissive.setHex(0);
                    currentIntersected = null;
                }
                return;
            }

            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            const intersects = raycaster.intersectObjects(cellObjects, false);

            if (intersects.length > 0) {
                if (currentIntersected !== intersects[0]) {
                    if (currentIntersected) {
                        // Убираем подсветку с предыдущей ячейки
                        currentIntersected.object.material.emissive.setHex(0);
                    }
                    currentIntersected = intersects[0];
                    // Подсвечиваем новую ячейку
                    currentIntersected.object.material.emissive.setHex(0x00ffff); // Голубая подсветка
                }
            } else {
                if (currentIntersected) {
                    currentIntersected.object.material.emissive.setHex(0);
                    currentIntersected = null;
                }
            }
        }

        function onPointerDown(event) {
            if (!gameActive) {
                return;
            }

            if (event.target !== renderer.domElement) return; // Игнорировать клики по UI

            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            const intersects = raycaster.intersectObjects(cellObjects, false);

            if (intersects.length > 0) {
                const clickedCellObject = intersects[0].object;
                const clickedCellId = clickedCellObject.userData.id;
                const clickedCell = cells.find(c => c.id === clickedCellId);

                if (clickedCell && (clickedCell.owner === null || clickedCell.owner === players[currentPlayerIndex].id)) {
                    clickedCell.addBall(players[currentPlayerIndex]);
                    switchPlayer(); // Передаем ход
                }
            }
        }

        // --- Управление UI ---

        function showOverlay(text, color) {
            overlayText.textContent = text;
            overlayText.style.color = `#${color.toString(16).padStart(6, '0')}`;
            messageOverlay.classList.add('visible');
        }

        restartButton.addEventListener('click', initGame);
        overlayRestartButton.addEventListener('click', initGame);

        startGameButton.addEventListener('click', () => {
            const inputVal = parseInt(playerCountInput.value);
            if (inputVal >= 2 && inputVal <= 6) {
                numPlayers = inputVal;
                playerCountInputContainer.style.display = 'none'; // Скрыть меню
                initThreeJS(); // Инициализация Three.js
                initGame(); // Начать новую игру
            } else {
                alert('Пожалуйста, введите число от 2 до 6.');
            }
        });

        // Инициализация при загрузке страницы (показываем меню выбора игроков)
        document.addEventListener('DOMContentLoaded', () => {
            playerCountInputContainer.style.display = 'flex'; // Показать меню
            infoPanel.style.display = 'none'; // Скрыть инфо-панель
            restartButton.style.display = 'none'; // Скрыть кнопку рестарта
            messageOverlay.classList.remove('visible'); // Скрыть оверлей
        });

    </script>
</body>
</html>